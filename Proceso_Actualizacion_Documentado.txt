
============================
ðŸ“„ ESPECIFICACIÃ“N FUNCIONAL
============================

Objetivo
--------
Actualizar la base histÃ³rica de registros `BD_RM.csv` utilizando los datos de `issues.csv`, respetando las reglas de actualizaciÃ³n y alta de registros detalladas a continuaciÃ³n.

Reglas del Proceso
------------------

1. IdentificaciÃ³n de Registros:
   - Campo clave: `#` en `issues.csv` corresponde a `RM` en `BD_RM.csv`.

2. Criterio de ActualizaciÃ³n:
   - Si el RM existe en ambos:
     - Mantener el registro con la fecha `Actualizado` mÃ¡s reciente.

3. Alta de Nuevos Registros:
   - Agregar registros de `issues.csv` que no existan en `BD_RM.csv`.

4. Campos a Actualizar o Completar:
   - Proyecto, Tipo, Tarea padre, Estado, Prioridad, Asunto, Actualizado por, Asignado a,
     Actualizado, Fecha de inicio, Fecha fin, Last updated by, ESTADO INTERNO.

5. Mapeo de Estado Interno:
   - Convertir Estado usando equivalencias definidas en el HTML (ver script).

6. Formato Final:
   - Conservar todas las columnas originales.
   - Agregar columna "Tipo de Registro": "Nuevo" o "Actualizado".

7. Salida Esperada:
   - Archivo: BD_RM_Actualizado_TipoRegistro.csv

====================
âœ… SCRIPT DE PYTHON
====================

import pandas as pd
from datetime import datetime

def parse_date(date_str):
    try:
        return datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
    except ValueError:
        try:
            return datetime.strptime(date_str, "%Y-%m-%d")
        except ValueError:
            return None

def procesar_actualizacion(bd_rm_path, issues_path, output_path):
    bd_rm_df = pd.read_csv(bd_rm_path, dtype=str)
    issues_df = pd.read_csv(issues_path, dtype=str)

    bd_rm_df['RM'] = bd_rm_df['RM'].astype(str)
    issues_df['#'] = issues_df['#'].astype(str)

    bd_rm_df['Actualizado_dt'] = bd_rm_df['Actualizado'].apply(parse_date)
    issues_df['Actualizado_dt'] = issues_df['Actualizado'].apply(parse_date)

    estado_interno_map = {
        "B- Completo": "20", "B- Rechazado": "20", "E-Alcance": "11", "E-Backlog": "11",
        "E-Cancelada": "20", "E-Desarrollo": "15", "E-Produccion": "20", "E-Stand By": "11",
        "E-Test Funcional": "16", "E-Test QA": "18", "MDA-AnAAlisis": "11", "MDA-AnAlisis": "12",
        "MDA-Analisis": "12", "MDA-Cerrado": "20", "MDA-Desarrollo": "15", "MDA-Pasaje PROD": "19",
        "MDA-Pendiente usuario": "19", "MDA-Rechazado": "20", "MDA-Resuelto": "20",
        "MDA-Test QA": "18", "MDA-Test funcional": "16", "R- Backlog": "11", "R- En curso": "12",
        "T-Cancelada": "20", "T-Finalizada": "20", "T-En Curso": "15", "T-Pasaje a ProducciÃ³n": "19",
        "T-Stand By": "14", "T-Solicitud de pasaje": "19", "T-Pasaje a Produccion": "19"
    }

    issues_df['ESTADO INTERNO'] = issues_df['Estado'].map(estado_interno_map).fillna("")

    target_columns = list(bd_rm_df.columns)
    additional_columns = ["Proyecto", "Tipo", "Tarea padre", "Fecha de inicio", "Fecha fin", "Last updated by"]
    for col in additional_columns:
        if col not in target_columns:
            bd_rm_df[col] = ""
            target_columns.append(col)

    existing_rms = set(bd_rm_df['RM'])
    updates_indexed = issues_df.set_index('#')
    updated_records = []

    for _, base_row in bd_rm_df.iterrows():
        rm = base_row['RM']
        if rm in updates_indexed.index:
            update_row = updates_indexed.loc[rm]
            if base_row['Actualizado_dt'] is None or (update_row['Actualizado_dt'] and update_row['Actualizado_dt'] > base_row['Actualizado_dt']):
                for col in additional_columns + ["Estado", "Prioridad", "Asunto", "Actualizado por", "Asignado a", "Actualizado"]:
                    base_row[col] = update_row.get(col, base_row.get(col, ""))
                base_row['ESTADO INTERNO'] = update_row['ESTADO INTERNO']
            base_row['Tipo de Registro'] = "Actualizado"
        else:
            base_row['Tipo de Registro'] = "Actualizado"
        updated_records.append(base_row)

    nuevos = issues_df[~issues_df['#'].isin(existing_rms)]
    for _, new_row in nuevos.iterrows():
        nuevo_registro = {col: "" for col in target_columns}
        nuevo_registro.update({
            "RM": new_row['#'],
            "Proyecto": new_row.get('Proyecto', ''),
            "Tipo": new_row.get('Tipo', ''),
            "Tarea padre": new_row.get('Tarea padre', ''),
            "Estado": new_row.get('Estado', ''),
            "Prioridad": new_row.get('Prioridad', ''),
            "Asunto": new_row.get('Asunto', ''),
            "Actualizado por": new_row.get('Actualizado por', ''),
            "Asignado a": new_row.get('Asignado a', ''),
            "Actualizado": new_row.get('Actualizado', ''),
            "Fecha de inicio": new_row.get('Fecha de inicio', ''),
            "Fecha fin": new_row.get('Fecha fin', ''),
            "Last updated by": new_row.get('Last updated by', ''),
            "ESTADO INTERNO": new_row.get('ESTADO INTERNO', ''),
            "Tipo de Registro": "Nuevo"
        })
        updated_records.append(pd.Series(nuevo_registro))

    final_df = pd.DataFrame(updated_records, columns=target_columns + ["Tipo de Registro"])
    final_df.to_csv(output_path, index=False, encoding="utf-8-sig")
    print(f"Archivo generado correctamente en: {output_path}")

# Ejemplo de uso:
# procesar_actualizacion('BD_RM.csv', 'issues.csv', 'BD_RM_Actualizado_TipoRegistro.csv')
